mod args;

use args::Args;
use heck::ToUpperCamelCase;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::{format_ident, quote, ToTokens};
use syn::{
    parse::Parser, parse_macro_input, parse_quote, ExprCall, Field, FnArg, Ident, ItemFn, Type,
    Visibility,
};

/// Generates a proc macro from a function into an instance of MessageCommand TODO LINK
///
/// # Function formatting:
/// The function should be formatted like a normal rust function. The visibility of the generated
/// struct is inherated from the function, and aegs are provided via the following list
/// ## Function Args:
/// - currently all args are joined into one struct to act as persistant data.
///
/// # Macro Args:
/// These are passed in the atturbute by either `arg(value)` or `arg = value`, a list of args
/// and what they do is provided below. These are all optional, and defaults are listed below
/// - `name` - The name of the struct, defaults to the function name in upper camel case
///
// this function is kinda fucked code wise, ignore it
#[proc_macro_attribute]
pub fn command(args: TokenStream, input_stream: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input_stream as ItemFn);

    let mut runner_func = input.clone();
    runner_func.vis = Visibility::Inherited;
    runner_func.sig.ident = Ident::new("__runner", Span::mixed_site());

    let args = parse_macro_input!(args as Args);

    let soucrce_ident = &input.sig.ident;
    let name = if let Some(name) = args.name {
        name
    } else {
        format_ident!(
            "{}",
            soucrce_ident.to_string().to_upper_camel_case(),
            span = soucrce_ident.span()
        )
    };

    let visibility = &input.vis;
    let (impl_generics, ty_generics, where_clause) = input.sig.generics.split_for_impl();

    let mut types: Vec<&Type> = Vec::new();

    for i in &input.sig.inputs {
        let ty = get_arg_type(i);
        types.push(ty);
    }

    let runner_call = format_runner_call(types.len());

    let data_name = format_ident!("{}GeneratedData", name);
    let (data_type, unit_data) = decide_data_type(types, &data_name);
    let mod_name = format_ident!("__{}_internal", name);

    let main_struct = if unit_data {
        quote!(#visibility struct #name #ty_generics #where_clause;)
    } else {
        quote!(
            #visibility struct #name #ty_generics #where_clause {
                data: #mod_name::#data_name
            }
        )
    };

    let constructor = if unit_data {
        quote!(Self)
    } else {
        quote!(Self { data })
    };

    let save = if unit_data {
        quote!(())
    } else {
        quote!(self.data)
    };

    let expanded = quote! {
        /// This is an autogenerated struct from a function, please see the documentation
        /// of the [floppa_macros::command](`command`) attribute macro
        #main_struct
        #[allow(non_snake_case)]
        #[doc(hidden)]
        mod #mod_name {

            use super::#name;
            #data_type

            #[warn(non_snake_case)]
            #runner_func

            #[async_trait::async_trait]
            #[allow(unused_variables)]
            impl #impl_generics floppa::Command<'_> for #name #ty_generics #where_clause {
                type Data = #data_name;

                fn construct(_cfg: &floppa::ThreadCfg, _cli: &floppa::Cli, data: Self::Data) -> Self {
                    #constructor
                }

                async fn execute(&mut self,
                        event: &twilight_model::gateway::payload::incoming::MessageCreate,
                        http: std::sync::Arc<floppa::HttpClient>)
                    -> floppa::FlopResult<()>
                {
                    #runner_call

                    http.create_message(event.channel_id)
                        .reply(event.id)
                        .content(&msg)?
                    .await?;
                    Ok(())
                }

                fn save(self) -> Self::Data {
                    #save
                }

                fn raw(&self) -> &'static str {
                    "todo"
                }
            }
        }
    };

    TokenStream::from(expanded)
}

fn get_arg_type(arg: &FnArg) -> &Type {
    match arg {
        FnArg::Receiver(rec) => &rec.ty,
        FnArg::Typed(pat) => &pat.ty,
    }
}

fn decide_data_type(types: Vec<&Type>, name: &Ident) -> (proc_macro2::TokenStream, bool) {
    if types.is_empty() {
        (quote!(pub(super) type #name = ();), true)
    } else if types.len() == 1 {
        let ty = types[0];
        (quote!(pub(super) type #name = #ty;), false)
    } else {
        let mut counter = -1;
        let fields = types.into_iter().map(|x| -> Field {
            counter += 1;
            Field::parse_named
                .parse_str(&format!("field{counter}:{}", x.to_token_stream()))
                .unwrap()
        });

        (
            parse_quote!(
                #[derive(std::fmt::Debug, serde::Serialize, serde::Deserialize)]
                pub struct #name {
                    #(#fields),*
                }
            ),
            false,
        )
    }
}

fn format_runner_call(len: usize) -> proc_macro2::TokenStream {
    let call: Result<ExprCall, syn::Error> = if len == 0 {
        syn::parse_str("__runner()")
    } else if len == 1 {
        syn::parse_str("__runner(self.data)")
    } else {
        let mut raw_call = "__runner(".to_string();
        for i in 0..len {
            raw_call = format!("{raw_call}self.data.field{i},")
        }

        syn::parse_str(&format!("{raw_call})"))
    };

    match call {
        Ok(call) => quote!(let msg: String = #call.to_string();),
        Err(e) => e.to_compile_error(),
    }
}
